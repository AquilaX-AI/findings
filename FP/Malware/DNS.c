#include <pthread.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <signal.h>
#include <sys/time.h>
#include <arpa/inet.h>
#include <netinet/ip.h>
#include <netinet/udp.h>

#define MAX_THREADS 10
#define MAX_SCANS 1000
#define SCAN_DELAY 500
#define DNS_QUERY_SIZE 64
#define TIMEOUT 3     

struct DNS_HEADER {
    unsigned short id;
    unsigned char rd :1;
    unsigned char tc :1;
    unsigned char aa :1;
    unsigned char opcode :4;
    unsigned char qr :1;
    unsigned char rcode :4;
    unsigned char cd :1;
    unsigned char ad :1;
    unsigned char z :1;
    unsigned char ra :1;
    unsigned short q_count;
    unsigned short ans_count;
    unsigned short auth_count;
    unsigned short add_count;
};

struct QUESTION {
    unsigned short qtype;
    unsigned short qclass;
};

volatile int running_threads = 0;
volatile unsigned long scanned = 0;
volatile int dns_servers_found = 0;

void sighandler(int sig) {
    printf("\nScan interrupted. Exiting...\n");
    exit(0);
}

void format_dns_query(unsigned char* dns, unsigned char* host) {
    int lock = 0, i;
    strcat((char*)host, ".");
    for(i = 0; i < strlen((char*)host); i++) {
        if(host[i] == '.') {
            *dns++ = i - lock;
            for(; lock < i; lock++) {
                *dns++ = host[lock];
            }
            lock++;
        }
    }
    *dns++ = '\0';
}

void *scan_dns(void *param) {
    running_threads++;
    char *target_ip = (char *)param;
    int sock;
    struct sockaddr_in servaddr;
    char query[DNS_QUERY_SIZE];
    struct DNS_HEADER *dns = (struct DNS_HEADER *) query;
    struct QUESTION *qinfo = NULL;
    unsigned char *qname;

    memset(query, 0, sizeof(query));
    dns->id = (unsigned short) htons(rand());
    dns->qr = 0; 
    dns->opcode = 0;
    dns->aa = 0;
    dns->tc = 0;
    dns->rd = 1;
    dns->ra = 0;
    dns->z = 0;
    dns->ad = 0;
    dns->cd = 0;
    dns->rcode = 0;
    dns->q_count = htons(1);
    dns->ans_count = 0;
    dns->auth_count = 0;
    dns->add_count = htons(1);
    qname = (unsigned char*)&query[sizeof(struct DNS_HEADER)];
    format_dns_query(qname, (unsigned char*) "example.com");
    qinfo = (struct QUESTION*)&query[sizeof(struct DNS_HEADER) + (strlen((const char*)qname) + 1)];
    qinfo->qtype = htons(1);
    qinfo->qclass = htons(1);

    // Setup UDP socket
    if ((sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0) {
        perror("Socket error");
        running_threads--;
        return NULL;
    }

    servaddr.sin_family = AF_INET;
    servaddr.sin_port = htons(53);
    servaddr.sin_addr.s_addr = inet_addr(target_ip);

    struct timeval timeout;
    timeout.tv_sec = TIMEOUT;
    timeout.tv_usec = 0;
    setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, (const char*)&timeout, sizeof(timeout));

    // Send DNS request
    sendto(sock, query, sizeof(query), 0, (struct sockaddr*)&servaddr, sizeof(servaddr));

    // Listen for response
    char buffer[512];
    struct sockaddr_in response_addr;
    socklen_t addr_len = sizeof(response_addr);
    int recv_bytes = recvfrom(sock, buffer, sizeof(buffer), 0, (struct sockaddr*)&response_addr, &addr_len);

    if (recv_bytes > 0) {
        dns_servers_found++;
        printf("[+] DNS Server Found: %s\n", target_ip);
    } else {
        printf("[-] No DNS response from: %s\n", target_ip);
    }

    close(sock);
    scanned++;
    running_threads--;
    return NULL;
}

int main(int argc, char *argv[]) {
    if (argc < 4) {
        fprintf(stderr, "Usage: %s <start IP> <end IP> <threads (max %d)>\n", argv[0], MAX_THREADS);
        exit(EXIT_FAILURE);
    }

    signal(SIGINT, sighandler);

    char start_ip[16], end_ip[16];
    strncpy(start_ip, argv[1], 15);
    strncpy(end_ip, argv[2], 15);
    int num_threads = atoi(argv[3]);

    if (num_threads > MAX_THREADS) {
        printf("Too many threads! Limiting to %d.\n", MAX_THREADS);
        num_threads = MAX_THREADS;
    }

    struct in_addr start_addr, end_addr;
    inet_aton(start_ip, &start_addr);
    inet_aton(end_ip, &end_addr);

    unsigned long ip_start = ntohl(start_addr.s_addr);
    unsigned long ip_end = ntohl(end_addr.s_addr);
    unsigned long total_ips = ip_end - ip_start + 1;

    printf("Scanning from %s to %s with %d threads...\n", start_ip, end_ip, num_threads);

    pthread_t threads[num_threads];
    unsigned long scanned_ips = 0;

    while (ip_start <= ip_end && scanned_ips < MAX_SCANS) {
        if (running_threads < num_threads) {
            char ip_str[16];
            struct in_addr curr_addr;
            curr_addr.s_addr = htonl(ip_start);
            inet_ntop(AF_INET, &curr_addr, ip_str, sizeof(ip_str));

            pthread_create(&threads[running_threads], NULL, scan_dns, strdup(ip_str));
            ip_start++;
            scanned_ips++;
        }
        usleep(SCAN_DELAY * 1000);
    }

    while (running_threads > 0) {
        sleep(1);
    }

    printf("\nScan complete. Found %d DNS servers.\n", dns_servers_found);
    return 0;
}
