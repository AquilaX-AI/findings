import os
import socket
import ssl
import sys
import threading
import subprocess

HOST = "127.0.0.1" 
PORT = 65432
CERTFILE = "server.crt" 
KEYFILE = "server.key" 
WHITELISTED_COMMANDS = ["ls", "pwd", "whoami", "echo", "date", "uptime"] 

def execute_command(command):
    """Executes a shell command securely."""
    cmd_parts = command.strip().split(" ")
    if cmd_parts[0] not in WHITELISTED_COMMANDS:
        return "[ERROR] Command not allowed!\n"
    
    try:
        result = subprocess.check_output(cmd_parts, stderr=subprocess.STDOUT, shell=False)
        return result.decode("utf-8") + "\n"
    except subprocess.CalledProcessError as e:
        return f"[ERROR] {e}\n"

def handle_client(conn, addr):
    """Handles communication with a client."""
    print(f"[INFO] Connection from {addr}")

    conn.sendall(b"Welcome to Secure Remote Shell. Type 'exit' to disconnect.\n")

    while True:
        conn.sendall(b">>> ")
        data = conn.recv(1024).strip().decode()

        if not data or data.lower() == "exit":
            break

        response = execute_command(data)
        conn.sendall(response.encode())

    print(f"[INFO] Connection closed from {addr}")
    conn.close()

def start_server():
    """Starts the secure remote shell server."""
    context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
    context.load_cert_chain(certfile=CERTFILE, keyfile=KEYFILE)

    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_sock:
        server_sock.bind((HOST, PORT))
        server_sock.listen(5)
        print(f"[INFO] Secure Shell Server started on {HOST}:{PORT}")

        while True:
            client_sock, addr = server_sock.accept()
            secure_conn = context.wrap_socket(client_sock, server_side=True)

            client_thread = threading.Thread(target=handle_client, args=(secure_conn, addr))
            client_thread.start()
